<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Quarter Note Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #38bdf8;
            --accent-hover: #7dd3fc;
            --danger: #ef4444;
            --success: #22c55e;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-family);
            line-height: 1.6;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(to right, #38bdf8, #818cf8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        p.subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .upload-section {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            border: 2px dashed #334155;
            transition: border-color 0.3s ease;
            margin-bottom: 2rem;
            cursor: pointer;
        }

        .upload-section:hover {
            border-color: var(--accent);
        }

        #file-input {
            display: none;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            margin: 0.5rem 0;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }

        .chart-container {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 1rem;
            height: 400px;
        }

        .insight-section {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1rem;
            margin-bottom: 2rem;
        }

        .insight-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .insight-content {
            color: var(--text-secondary);
        }

        .tag {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .tag-good {
            background-color: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .tag-warning {
            background-color: rgba(234, 179, 8, 0.2);
            color: #facc15;
        }

        .tag-danger {
            background-color: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: var(--card-bg);
            border-radius: 1rem;
            overflow: hidden;
            margin-top: 2rem;
        }

        th,
        td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #334155;
        }

        th {
            background-color: #1e293b;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .config-panel {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 1rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            border: 1px solid #334155;
        }

        .toggle-group {
            display: flex;
            background: #0f172a;
            padding: 0.25rem;
            border-radius: 0.5rem;
        }

        .toggle-btn {
            padding: 0.5rem 1rem;
            border-radius: 0.4rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .toggle-btn.active {
            background: var(--accent);
            color: var(--bg-color);
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Piano Visualization Styles */
        .piano-section {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1rem;
            margin-bottom: 2rem;
        }

        .piano-section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .piano-legend {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend-color.ascending {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }

        .legend-color.descending {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }

        .legend-color.deviation {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
        }

        .legend-color.crossing {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .piano-container {
            overflow-x: auto;
            padding: 1rem 0;
        }

        .piano-wrapper {
            display: flex;
            justify-content: center;
            min-width: fit-content;
        }

        .piano {
            display: flex;
            position: relative;
            height: 180px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            padding: 10px 5px 15px 5px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .white-key {
            width: 44px;
            height: 150px;
            background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 85%, #d4d4d4 100%);
            border: 1px solid #bbb;
            border-radius: 0 0 6px 6px;
            margin: 0 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 8px;
            z-index: 1;
        }

        .white-key:hover {
            background: linear-gradient(180deg, #f8f8f8 0%, #e8e8e8 85%, #c8c8c8 100%);
        }

        .white-key.played {
            background: linear-gradient(180deg, #bbf7d0 0%, #86efac 85%, #4ade80 100%);
            border-color: #22c55e;
        }

        .white-key.played.ascending {
            background: linear-gradient(180deg, #bbf7d0 0%, #86efac 85%, #4ade80 100%);
            border-color: #22c55e;
            box-shadow: inset 0 -5px 15px rgba(34, 197, 94, 0.3);
        }

        .white-key.played.descending {
            background: linear-gradient(180deg, #bfdbfe 0%, #93c5fd 85%, #60a5fa 100%);
            border-color: #3b82f6;
            box-shadow: inset 0 -5px 15px rgba(59, 130, 246, 0.3);
        }

        .white-key.played.deviation {
            background: linear-gradient(180deg, #fecaca 0%, #fca5a5 85%, #f87171 100%);
            border-color: #ef4444;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.6), inset 0 -5px 15px rgba(239, 68, 68, 0.3);
            animation: pulse-deviation 1.5s ease-in-out infinite;
        }

        .black-key {
            width: 28px;
            height: 95px;
            background: linear-gradient(180deg, #3a3a3a 0%, #1a1a1a 60%, #0a0a0a 100%);
            border-radius: 0 0 4px 4px;
            position: absolute;
            top: 10px;
            z-index: 2;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .black-key:hover {
            background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 60%, #1a1a1a 100%);
        }

        .black-key.played.ascending {
            background: linear-gradient(180deg, #166534 0%, #15803d 60%, #16a34a 100%);
            box-shadow: 0 0 12px rgba(34, 197, 94, 0.5);
        }

        .black-key.played.descending {
            background: linear-gradient(180deg, #1e40af 0%, #1d4ed8 60%, #2563eb 100%);
            box-shadow: 0 0 12px rgba(59, 130, 246, 0.5);
        }

        .black-key.played.deviation {
            background: linear-gradient(180deg, #991b1b 0%, #b91c1c 60%, #dc2626 100%);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.7);
            animation: pulse-deviation 1.5s ease-in-out infinite;
        }

        @keyframes pulse-deviation {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }


        .finger-badge {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
            font-size: 14px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5);
            pointer-events: none;
            z-index: 10;
        }

        .black-key .finger-badge {
            top: 40%;
            width: 22px;
            height: 22px;
            font-size: 11px;
        }

        .finger-badge.crossing {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.5);
        }

        .finger-badge.crossing::after {
            content: '‚Üª';
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 12px;
            background: #f59e0b;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sequence-number {
            position: absolute;
            bottom: 4px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 8px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        .black-key .sequence-number {
            color: rgba(255, 255, 255, 0.5);
            bottom: 2px;
        }

        .key-label {
            position: absolute;
            bottom: 16px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            pointer-events: none;
        }

        .black-key .key-label {
            color: #888;
            bottom: 12px;
            font-size: 8px;
        }

        .key-stats {
            position: absolute;
            bottom: 32px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 9px;
            font-weight: 800;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            line-height: 1.1;
            gap: 0px;
        }

        .white-key .key-stats {
            color: rgba(0, 0, 0, 0.6);
        }

        .black-key .key-stats {
            color: rgba(255, 255, 255, 0.7);
        }

        .stat-offset {
            color: #f87171;
        }

        .played.ascending .stat-offset,
        .played.descending .stat-offset {
            color: inherit;
        }

        .stat-velocity {
            color: #38bdf8;
        }

        .played.ascending .stat-velocity,
        .played.descending .stat-velocity {
            color: inherit;
        }

        .direction-arrow {
            position: absolute;
            top: 8px;
            right: 4px;
            font-size: 14px;
            pointer-events: none;
        }

        .piano-info {
            text-align: center;
            margin-top: 1rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .pattern-timeline {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
        }

        .pattern-timeline-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
        }

        .pattern-flow {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }

        .pattern-note {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            min-width: 45px;
            transition: transform 0.2s ease;
        }

        .pattern-note:hover {
            transform: scale(1.1);
        }

        .pattern-note.ascending {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(34, 197, 94, 0.1));
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: #4ade80;
        }

        .pattern-note.descending {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.5);
            color: #60a5fa;
        }

        .pattern-note.deviation {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.1));
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #f87171;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.3);
        }

        .pattern-note .note-name {
            font-size: 11px;
            opacity: 0.8;
        }

        .pattern-note .finger-num {
            font-size: 16px;
            font-weight: 700;
        }

        .pattern-arrow {
            color: var(--text-secondary);
            font-size: 16px;
        }

        /* Direction Section Styles */
        .direction-section {
            margin: 1.5rem 0;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 2px solid;
        }

        .ascending-section {
            border-color: rgba(34, 197, 94, 0.3);
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.05) 0%, transparent 100%);
        }

        .descending-section {
            border-color: rgba(59, 130, 246, 0.3);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, transparent 100%);
        }

        .direction-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .direction-icon {
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
        }

        .ascending-section .direction-icon {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .descending-section .direction-icon {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .direction-title {
            font-size: 1.1rem;
            font-weight: 600;
            flex: 1;
        }

        .ascending-section .direction-title {
            color: #4ade80;
        }

        .descending-section .direction-title {
            color: #60a5fa;
        }

        .direction-count {
            font-size: 0.875rem;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-weight: 500;
        }

        .ascending-section .direction-count {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .descending-section .direction-count {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .direction-section .piano {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
        }

        .direction-section .pattern-timeline {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.15);
        }

        .empty-section-message {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
    </div>

    <div class="container">
        <header>
            <h1>MIDI Quarter Note Analyzer</h1>
            <p class="subtitle">Analyze velocity consistency and grid timing accuracy</p>
        </header>

        <div class="upload-section" onclick="document.getElementById('file-input').click()">
            <p>Click to upload or drag and drop your MIDI file</p>
            <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem;">Recommended: Individual
                quarter note recordings</p>
            <input type="file" id="file-input" accept=".mid,.midi">
        </div>

        <div class="config-panel">
            <span style="font-weight: 600; color: var(--text-secondary);">Select Hand:</span>
            <div class="toggle-group">
                <button class="toggle-btn" onclick="setHand('LH', this)">Left Hand</button>
                <button class="toggle-btn active" onclick="setHand('RH', this)">Right Hand</button>
            </div>
        </div>

        <div id="results" style="display: none;">
            <div class="dashboard">
                <div class="stat-card">
                    <div class="stat-label">Avg. Velocity</div>
                    <div class="stat-value" id="avg-velocity">-</div>
                    <div class="stat-label" id="velocity-jitter">Jitter: -</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg. Offset</div>
                    <div class="stat-value" id="avg-offset">-</div>
                    <div class="stat-label">ms from grid</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Timing Consistency</div>
                    <div class="stat-value" id="timing-consistency">-</div>
                    <div class="stat-label">Std. Deviation</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Note Count</div>
                    <div class="stat-value" id="note-count">-</div>
                    <div class="stat-label">Quarter Notes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Deviation Rate</div>
                    <div class="stat-value" id="deviation-rate">-</div>
                    <div class="stat-label" id="deviation-count">0 Deviations</div>
                </div>
            </div>

            <!-- Piano Visualization Section -->
            <div class="piano-section">
                <div class="piano-section-title">üéπ Scale Pattern Visualization</div>
                <div class="piano-legend">
                    <div class="legend-item">
                        <div class="legend-color ascending"></div>
                        <span>Normal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color deviation"></div>
                        <span>Deviation (timing/velocity issue)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color crossing"></div>
                        <span>Finger Crossing</span>
                    </div>
                </div>

                <!-- Ascending Section -->
                <div class="direction-section ascending-section">
                    <div class="direction-header">
                        <span class="direction-icon">‚Üë</span>
                        <span class="direction-title">Ascending Pattern</span>
                        <span class="direction-count" id="ascending-count">0 notes</span>
                    </div>
                    <div class="piano-container">
                        <div class="piano-wrapper">
                            <div class="piano" id="piano-ascending">
                                <!-- Keys will be generated by JavaScript -->
                            </div>
                        </div>
                    </div>
                    <div class="pattern-timeline">
                        <div class="pattern-timeline-title">üìç Ascending Sequence</div>
                        <div class="pattern-flow" id="pattern-flow-ascending">
                            <!-- Pattern will be generated by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Descending Section -->
                <div class="direction-section descending-section">
                    <div class="direction-header">
                        <span class="direction-icon">‚Üì</span>
                        <span class="direction-title">Descending Pattern</span>
                        <span class="direction-count" id="descending-count">0 notes</span>
                    </div>
                    <div class="piano-container">
                        <div class="piano-wrapper">
                            <div class="piano" id="piano-descending">
                                <!-- Keys will be generated by JavaScript -->
                            </div>
                        </div>
                    </div>
                    <div class="pattern-timeline">
                        <div class="pattern-timeline-title">üìç Descending Sequence</div>
                        <div class="pattern-flow" id="pattern-flow-descending">
                            <!-- Pattern will be generated by JavaScript -->
                        </div>
                    </div>
                </div>

                <div class="piano-info" id="piano-info">
                    Upload a MIDI file to see the scale pattern
                </div>
            </div>

            <div class="insight-section">
                <div class="insight-title">
                    <span>Performance Insight</span>
                    <span id="insight-tags"></span>
                </div>
                <div class="insight-content" id="insight-text">
                    Parsing MIDI data...
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-container">
                    <canvas id="velocityChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="offsetChart"></canvas>
                </div>
            </div>

            <div class="insight-section">
                <div class="insight-title">Finger-Note Distribution: Ascending</div>
                <div class="chart-container" style="height: 400px; margin-bottom: 2rem;">
                    <canvas id="fingerNoteChartAsc"></canvas>
                </div>
                <div id="aggregate-stats-asc"></div>
            </div>

            <div class="insight-section">
                <div class="insight-title">Finger-Note Distribution: Descending</div>
                <div class="chart-container" style="height: 400px; margin-bottom: 2rem;">
                    <canvas id="fingerNoteChartDesc"></canvas>
                </div>
                <div id="aggregate-stats-desc"></div>
            </div>

            <table id="note-table">
                <thead>
                    <tr>
                        <th>Note #</th>
                        <th>Name</th>
                        <th>Velocity</th>
                        <th>Finger</th>
                        <th>Target (Grid)</th>
                        <th>Actual Time</th>
                        <th>Offset (ms)</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="note-table-body">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('file-input');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');

        let velocityChart = null;
        let offsetChart = null;
        let fingerNoteChartAsc = null;
        let fingerNoteChartDesc = null;
        let currentMidi = null;
        let selectedHand = 'RH';

        function setHand(hand, btn) {
            selectedHand = hand;
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            if (currentMidi) analyzeMidi(currentMidi);
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            loading.style.display = 'flex';

            try {
                const arrayBuffer = await file.arrayBuffer();
                currentMidi = new Midi(arrayBuffer);
                analyzeMidi(currentMidi);
                results.style.display = 'block';
            } catch (err) {
                console.error(err);
                alert("Error parsing MIDI file. Make sure it's a valid .mid file.");
            } finally {
                loading.style.display = 'none';
            }
        });

        function analyzeMidi(midi) {
            const notes = [];
            const ppq = midi.header.ppq;

            const track = midi.tracks.find(t => t.notes.length > 0) || midi.tracks[0];

            if (!track || track.notes.length === 0) {
                alert("No notes found in the MIDI file.");
                return;
            }

            const bpm = midi.header.tempos.length > 0 ? midi.header.tempos[0].bpm : 120;
            const msPerTick = (60 * 1000) / (bpm * ppq);

            track.notes.forEach((note, index) => {
                const gridTick = Math.round(note.ticks / ppq) * ppq;
                const offsetTicks = note.ticks - gridTick;
                const offsetMs = offsetTicks * msPerTick;

                notes.push({
                    index: index + 1,
                    name: note.name,
                    midi: note.midi,
                    velocity: Math.round(note.velocity * 127),
                    targetTicks: gridTick,
                    actualTicks: note.ticks,
                    offsetMs: offsetMs,
                    time: note.time
                });
            });

            // Perform Scale Analysis
            const analyzedNotes = analyzeScaleAndFingering(notes);

            updateStats(analyzedNotes);
            updateCharts(analyzedNotes);
            updateTable(analyzedNotes);
            updatePianoVisualization(analyzedNotes);
            generateInsights(analyzedNotes);
        }

        function analyzeScaleAndFingering(notes) {
            if (notes.length < 2) return notes;

            // 1. Detect Direction and Segments
            let segments = [];
            let currentSegment = { notes: [notes[0]], direction: null };

            for (let i = 1; i < notes.length; i++) {
                const prev = notes[i - 1];
                const curr = notes[i];
                const diff = curr.midi - prev.midi;
                const direction = diff > 0 ? 'ascending' : (diff < 0 ? 'descending' : 'static');

                if (currentSegment.direction === null) {
                    currentSegment.direction = direction;
                    currentSegment.notes.push(curr);
                } else if (direction === currentSegment.direction || direction === 'static') {
                    currentSegment.notes.push(curr);
                } else {
                    segments.push(currentSegment);
                    currentSegment = { notes: [curr], direction: direction };
                }
            }
            segments.push(currentSegment);

            // 2. Assign Fingering based on scale degree position
            notes.forEach(n => { n.fingering = null; n.isDeviation = false; n.isCrossing = false; n.pitchName = n.name.replace(/[0-9]/g, ''); });

            // Define fingering patterns by scale degree (1-8 = C D E F G A B C for C major)
            // Pattern maps scale degree (0-7 for one octave) to finger number
            // These repeat every octave
            const fingeringPatterns = {
                RH_asc: { 0: 1, 1: 2, 2: 3, 3: 1, 4: 2, 5: 3, 6: 4, 7: 5 }, // C=1, D=2, E=3, F=1, G=2, A=3, B=4, C=5 (then repeats with thumb)
                RH_desc: { 0: 1, 1: 2, 2: 3, 3: 1, 4: 2, 5: 3, 6: 4, 7: 5 }, // Same mapping, just traversed in reverse
                LH_asc: { 0: 5, 1: 4, 2: 3, 3: 2, 4: 1, 5: 3, 6: 2, 7: 1 }, // C=5, D=4, E=3, F=2, G=1, A=3, B=2, C=1
                LH_desc: { 0: 5, 1: 4, 2: 3, 3: 2, 4: 1, 5: 3, 6: 2, 7: 1 }  // Same mapping, just traversed in reverse
            };

            // Map note names to scale degrees (C major scale)
            const noteToDegree = { 'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6 };

            segments.forEach(seg => {
                const isAsc = seg.direction === 'ascending';
                const patternKey = selectedHand + '_' + (isAsc ? 'asc' : 'desc');
                const pattern = fingeringPatterns[patternKey];

                // Track previous finger for crossing detection
                let prevFinger = null;

                seg.notes.forEach((note, i) => {
                    const pitchName = note.pitchName;
                    const degree = noteToDegree[pitchName];

                    if (degree !== undefined && pattern[degree] !== undefined) {
                        note.fingering = pattern[degree];

                        // Detect crossings (thumb-under or finger-over)
                        if (prevFinger !== null) {
                            if (selectedHand === 'RH') {
                                // RH ascending: crossing when going to thumb (finger 1) from higher finger
                                // RH descending: crossing when going from thumb to finger 3
                                if (isAsc && note.fingering === 1 && prevFinger > 1) {
                                    note.isCrossing = true;
                                } else if (!isAsc && prevFinger === 1 && note.fingering === 3) {
                                    note.isCrossing = true;
                                }
                            } else { // LH
                                // LH ascending: crossing when going from thumb to finger 3
                                // LH descending: crossing when going to thumb (finger 1) from higher finger
                                if (isAsc && prevFinger === 1 && note.fingering === 3) {
                                    note.isCrossing = true;
                                } else if (!isAsc && note.fingering === 1 && prevFinger > 1) {
                                    note.isCrossing = true;
                                }
                            }
                        }
                        prevFinger = note.fingering;
                    } else {
                        // For non-diatonic notes, fall back to sequential assignment
                        const fallbackPattern = selectedHand === 'RH'
                            ? (isAsc ? [1, 2, 3, 1, 2, 3, 4, 5] : [5, 4, 3, 2, 1, 3, 2, 1])
                            : (isAsc ? [5, 4, 3, 2, 1, 3, 2, 1] : [1, 2, 3, 1, 2, 3, 4, 5]);
                        note.fingering = fallbackPattern[i % fallbackPattern.length];
                        prevFinger = note.fingering;
                    }
                    note.direction = seg.direction;
                });
            });

            // 3. Mark Deviations
            for (let i = 0; i < notes.length; i++) {
                const note = notes[i];
                if (Math.abs(note.offsetMs) > 30) note.isDeviation = true;
                if (i > 0) {
                    if (Math.abs(note.velocity - notes[i - 1].velocity) > 25) note.isDeviation = true;
                }
            }

            return notes;
        }

        function updateStats(notes) {
            const velocities = notes.map(n => n.velocity);
            const offsets = notes.map(n => Math.abs(n.offsetMs));

            const avgVel = velocities.reduce((a, b) => a + b, 0) / notes.length;
            const avgOffset = offsets.reduce((a, b) => a + b, 0) / notes.length;

            const maxVel = Math.max(...velocities);
            const minVel = Math.min(...velocities);
            const jitter = maxVel - minVel;

            const squareDiffs = offsets.map(o => Math.pow(o - avgOffset, 2));
            const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / notes.length;
            const stdDev = Math.sqrt(avgSquareDiff);

            const deviationCount = notes.filter(n => n.isDeviation).length;
            const deviationRate = (deviationCount / notes.length) * 100;

            document.getElementById('avg-velocity').textContent = avgVel.toFixed(1);
            document.getElementById('velocity-jitter').textContent = `Range: ${jitter} (Min: ${minVel}, Max: ${maxVel})`;
            document.getElementById('avg-offset').textContent = avgOffset.toFixed(1);
            document.getElementById('timing-consistency').textContent = stdDev.toFixed(1);
            document.getElementById('note-count').textContent = notes.length;
            document.getElementById('deviation-rate').textContent = deviationRate.toFixed(1) + '%';
            document.getElementById('deviation-count').textContent = `${deviationCount} Deviations`;
        }

        function updateCharts(notes) {
            const labels = notes.map(n => n.index);
            const velocities = notes.map(n => n.velocity);
            const offsets = notes.map(n => n.offsetMs);

            if (velocityChart) velocityChart.destroy();
            if (offsetChart) offsetChart.destroy();
            if (fingerNoteChartAsc) fingerNoteChartAsc.destroy();
            if (fingerNoteChartDesc) fingerNoteChartDesc.destroy();

            const ctxVel = document.getElementById('velocityChart').getContext('2d');
            velocityChart = new Chart(ctxVel, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Velocity (0-127)',
                        data: velocities,
                        borderColor: '#38bdf8',
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointBackgroundColor: notes.map(n => n.isDeviation ? '#ef4444' : '#38bdf8'),
                        pointRadius: notes.map(n => n.isDeviation ? 6 : 3)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { min: 0, max: 127, grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        x: { grid: { display: false }, ticks: { color: '#94a3b8' } }
                    },
                    plugins: {
                        legend: { labels: { color: '#f8fafc' } },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const note = notes[context.dataIndex];
                                    let label = `Vel: ${note.velocity}`;
                                    if (note.fingering) label += ` | Finger: ${note.fingering}`;
                                    if (note.isCrossing) label += ` (Crossing)`;
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            const ctxOff = document.getElementById('offsetChart').getContext('2d');
            offsetChart = new Chart(ctxOff, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Offset from Grid (ms)',
                        data: offsets,
                        backgroundColor: notes.map(n => n.isDeviation ? 'rgba(239, 68, 68, 0.8)' : (n.offsetMs >= 0 ? 'rgba(34, 197, 94, 0.6)' : 'rgba(56, 189, 248, 0.6)')),
                        borderColor: notes.map(n => n.isDeviation ? '#ef4444' : (n.offsetMs >= 0 ? '#22c55e' : '#38bdf8')),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        x: { grid: { display: false }, ticks: { color: '#94a3b8' } }
                    },
                    plugins: {
                        legend: { labels: { color: '#f8fafc' } }
                    }
                }
            });

            // Finger-Note Analysis for Ascending
            const ascendingNotes = notes.filter(n => n.direction === 'ascending');
            fingerNoteChartAsc = renderFingerNoteSection('fingerNoteChartAsc', 'aggregate-stats-asc', ascendingNotes);

            // Finger-Note Analysis for Descending
            const descendingNotes = notes.filter(n => n.direction === 'descending');
            fingerNoteChartDesc = renderFingerNoteSection('fingerNoteChartDesc', 'aggregate-stats-desc', descendingNotes);
        }

        function renderFingerNoteSection(canvasId, tableContainerId, sectionNotes) {
            if (sectionNotes.length === 0) {
                document.getElementById(tableContainerId).innerHTML = '<p class="empty-section-message">No data for this direction</p>';
                document.getElementById(canvasId).style.display = 'none';
                return null;
            }
            document.getElementById(canvasId).style.display = 'block';

            const aggregates = aggregateAnalysis(sectionNotes);
            const fingerLabels = aggregates.map(a => `${a.note} (F${a.finger})`);
            const fingerPosOffsets = aggregates.map(a => a.avgPosOffset);
            const fingerNegOffsets = aggregates.map(a => a.avgNegOffset);
            const fingerVels = aggregates.map(a => a.avgVelocity);

            const ctx = document.getElementById(canvasId).getContext('2d');
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: fingerLabels,
                    datasets: [
                        {
                            label: 'Avg Late (ms)',
                            data: fingerPosOffsets,
                            backgroundColor: 'rgba(34, 197, 94, 0.7)',
                            borderColor: '#22c55e',
                            borderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Avg Early (ms)',
                            data: fingerNegOffsets,
                            backgroundColor: 'rgba(56, 189, 248, 0.7)',
                            borderColor: '#38bdf8',
                            borderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Avg Velocity',
                            data: fingerVels,
                            type: 'line',
                            borderColor: '#fbbf24',
                            backgroundColor: '#fbbf24',
                            borderDash: [5, 5],
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: { display: true, text: 'Offset (ms)', color: '#94a3b8' },
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8' }
                        },
                        y1: {
                            position: 'right',
                            title: { display: true, text: 'Velocity', color: '#94a3b8' },
                            grid: { display: false },
                            ticks: { color: '#94a3b8' },
                            min: 0, max: 127
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: '#94a3b8', autoSkip: false, maxRotation: 45, minRotation: 45 }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#f8fafc' } }
                    }
                }
            });

            updateAggregateTable(tableContainerId, aggregates);
            return chart;
        }

        function aggregateAnalysis(notes) {
            const groups = {};
            notes.forEach(n => {
                if (!n.fingering) return;
                const key = `${n.fingering}-${n.name}`;
                if (!groups[key]) {
                    groups[key] = { finger: n.fingering, note: n.name, midi: n.midi, posOffsets: [], negOffsets: [], velocities: [] };
                }
                if (n.offsetMs >= 0) {
                    groups[key].posOffsets.push(n.offsetMs);
                } else {
                    groups[key].negOffsets.push(n.offsetMs);
                }
                groups[key].velocities.push(n.velocity);
            });

            return Object.values(groups).map(g => {
                const posCount = g.posOffsets.length;
                const negCount = g.negOffsets.length;
                return {
                    finger: g.finger,
                    note: g.note,
                    midi: g.midi,
                    avgPosOffset: posCount > 0 ? g.posOffsets.reduce((a, b) => a + b, 0) / posCount : 0,
                    avgNegOffset: negCount > 0 ? g.negOffsets.reduce((a, b) => a + b, 0) / negCount : 0,
                    avgVelocity: g.velocities.reduce((a, b) => a + b, 0) / g.velocities.length,
                    count: posCount + negCount
                };
            }).sort((a, b) => a.midi - b.midi || a.finger - b.finger);
        }

        function updateAggregateTable(containerId, aggregates) {
            const container = document.getElementById(containerId);
            if (!container) return;
            let html = `
                <table style="margin-top: 1rem;">
                    <thead>
                        <tr>
                            <th>Finger</th>
                            <th>Note</th>
                            <th>Avg Early/Late (ms)</th>
                            <th>Avg Velocity</th>
                            <th>Sample Count</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            aggregates.forEach(a => {
                const posColor = a.avgPosOffset > 25 ? '#f87171' : (a.avgPosOffset < 15 ? '#4ade80' : 'inherit');
                const negColor = a.avgNegOffset < -25 ? '#f87171' : (a.avgNegOffset > -15 ? '#4ade80' : 'inherit');
                html += `
                    <tr>
                        <td>Finger ${a.finger}</td>
                        <td>${a.note}</td>
                        <td style="font-weight: bold;">
                            <span style="color: ${negColor}">${a.avgNegOffset.toFixed(1)}</span> / 
                            <span style="color: ${posColor}">+${a.avgPosOffset.toFixed(1)}</span>
                        </td>
                        <td>${a.avgVelocity.toFixed(1)}</td>
                        <td>${a.count}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updateTable(notes) {
            const tbody = document.getElementById('note-table-body');
            tbody.innerHTML = '';

            notes.forEach(n => {
                const tr = document.createElement('tr');
                if (n.isDeviation) tr.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';

                const statusIcon = n.isDeviation ? '‚ö†Ô∏è' : (n.isCrossing ? 'üîÑ' : '‚úÖ');
                const crossingText = n.isCrossing ? '<small>(Crossing)</small>' : '';

                tr.innerHTML = `
                    <td>${n.index}</td>
                    <td>${n.name}</td>
                    <td style="font-weight: bold; color: ${n.isDeviation ? '#f87171' : 'inherit'}">${n.velocity}</td>
                    <td>${n.fingering || '-'} ${crossingText}</td>
                    <td>${(n.targetTicks).toFixed(0)} ticks</td>
                    <td>${(n.actualTicks).toFixed(0)} ticks</td>
                    <td style="color: ${n.offsetMs >= 0 ? '#4ade80' : '#f87171'}">${n.offsetMs.toFixed(1)}</td>
                    <td>${statusIcon} ${n.isDeviation ? '<span style="color:#f87171; font-size: 0.7rem;">DEVIATION</span>' : ''}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function generateInsights(notes) {
            const velocities = notes.map(n => n.velocity);
            const offsets = notes.map(n => n.offsetMs);
            const absOffsets = offsets.map(Math.abs);

            const avgOffset = absOffsets.reduce((a, b) => a + b, 0) / notes.length;
            const maxVel = Math.max(...velocities);
            const minVel = Math.min(...velocities);
            const velRange = maxVel - minVel;

            const tagsContainer = document.getElementById('insight-tags');
            const textContainer = document.getElementById('insight-text');
            tagsContainer.innerHTML = '';

            let insights = [];

            const deviations = notes.filter(n => n.isDeviation);
            const crossingDeviations = notes.filter(n => n.isDeviation && n.isCrossing);

            if (deviations.length === 0) {
                tagsContainer.innerHTML += '<span class="tag tag-good">Perfect Consistency</span>';
                insights.push("Flawless execution! No significant deviations in timing or velocity detected.");
            } else {
                tagsContainer.innerHTML += `<span class="tag tag-danger">${deviations.length} Deviations</span>`;
                insights.push(`Detected <b>${deviations.length}</b> important deviations where the feel becomes uneven.`);
            }

            if (crossingDeviations.length > 0) {
                tagsContainer.innerHTML += '<span class="tag tag-warning">Crossing Issues</span>';
                insights.push(`<b>Warning:</b> Several deviations occur during finger-crossings (thumb-under/finger-over). Focus on smooth rotation at these points.`);
            }

            if (avgOffset < 15) {
                insights.push("Overall timing is professional grade.");
            } else if (avgOffset < 40) {
                insights.push("Overall timing is solid and rhythmic.");
            }

            const totalOffset = offsets.reduce((a, b) => a + b, 0);
            if (totalOffset > 10 * notes.length) {
                insights.push("A consistent tendency to play <b>behind the beat</b>.");
            } else if (totalOffset < -10 * notes.length) {
                insights.push("A consistent tendency to play <b>ahead of the beat</b>.");
            }

            if (velRange < 20) {
                insights.push("Dynamics are remarkably even across the scale.");
            }

            textContainer.innerHTML = insights.join('<br><br>');
        }

        // Piano Visualization Functions
        function updatePianoVisualization(notes) {
            // Separate notes by direction
            const ascendingNotes = notes.filter(n => n.direction === 'ascending');
            const descendingNotes = notes.filter(n => n.direction === 'descending');

            // Update counts
            document.getElementById('ascending-count').textContent = `${ascendingNotes.length} notes`;
            document.getElementById('descending-count').textContent = `${descendingNotes.length} notes`;

            // Render separate pianos
            renderPianoKeyboard('piano-ascending', ascendingNotes, 'ascending');
            renderPianoKeyboard('piano-descending', descendingNotes, 'descending');

            // Render separate timelines
            renderPatternTimeline('pattern-flow-ascending', ascendingNotes, 'ascending');
            renderPatternTimeline('pattern-flow-descending', descendingNotes, 'descending');

            // Update overall info
            updatePianoInfo(notes);
        }

        function renderPianoKeyboard(containerId, notes, direction) {
            const pianoContainer = document.getElementById(containerId);
            pianoContainer.innerHTML = '';

            if (notes.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-section-message';
                emptyMsg.textContent = `No ${direction} notes in this recording`;
                pianoContainer.parentElement.parentElement.querySelector('.piano-container').appendChild(emptyMsg);
                return;
            }

            // Determine the range of notes to display
            const midiNumbers = notes.map(n => n.midi);
            const minMidi = Math.min(...midiNumbers);
            const maxMidi = Math.max(...midiNumbers);

            // Extend range to include full octaves
            const startOctave = Math.floor((minMidi - 12) / 12);
            const endOctave = Math.ceil((maxMidi + 12) / 12);
            const startMidi = Math.max(21, startOctave * 12); // A0 is 21
            const endMidi = Math.min(108, endOctave * 12 + 11); // C8 is 108

            // Note names for each position in an octave
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const blackKeyNotes = ['C#', 'D#', 'F#', 'G#', 'A#'];

            // Create a map of MIDI numbers to note data
            const noteMap = {};
            notes.forEach((note, idx) => {
                if (!noteMap[note.midi]) {
                    noteMap[note.midi] = [];
                }
                noteMap[note.midi].push({ ...note, sequenceIndex: idx + 1 });
            });

            // Track white key positions for black key placement
            let whiteKeyIndex = 0;
            const whiteKeyPositions = [];

            // First pass: identify white key positions
            for (let midi = startMidi; midi <= endMidi; midi++) {
                const noteIndex = midi % 12;
                const noteName = noteNames[noteIndex];

                if (!blackKeyNotes.includes(noteName)) {
                    whiteKeyPositions.push({ midi, x: whiteKeyIndex * 46 }); // 44px width + 2px margin
                    whiteKeyIndex++;
                }
            }

            // Create white keys
            for (const keyInfo of whiteKeyPositions) {
                const midi = keyInfo.midi;
                const octave = Math.floor(midi / 12) - 1;
                const noteIndex = midi % 12;
                const noteName = noteNames[noteIndex];
                const fullNoteName = noteName + octave;

                const key = document.createElement('div');
                key.className = 'white-key';
                key.dataset.midi = midi;
                key.dataset.note = fullNoteName;

                // Check if this note was played
                if (noteMap[midi]) {
                    const noteData = noteMap[midi];
                    const lastPlayed = noteData[noteData.length - 1];

                    key.classList.add('played');
                    if (lastPlayed.isDeviation) {
                        key.classList.add('deviation');
                    } else {
                        key.classList.add(direction);
                    }

                    // Add finger badge
                    if (lastPlayed.fingering) {
                        const badge = document.createElement('div');
                        badge.className = 'finger-badge' + (lastPlayed.isCrossing ? ' crossing' : '');
                        badge.textContent = lastPlayed.fingering;
                        key.appendChild(badge);
                    }

                    // Add sequence numbers
                    const seqNums = noteData.map(n => n.sequenceIndex).join(',');
                    const seqLabel = document.createElement('div');
                    seqLabel.className = 'sequence-number';
                    seqLabel.textContent = seqNums.length > 6 ? seqNums.substring(0, 5) + '‚Ä¶' : seqNums;
                    key.appendChild(seqLabel);

                    // Add stats (Avg Offset and Avg Velocity)
                    const avgOffset = noteData.reduce((sum, n) => sum + n.offsetMs, 0) / noteData.length;
                    const avgVel = noteData.reduce((sum, n) => sum + n.velocity, 0) / noteData.length;

                    const statsLabel = document.createElement('div');
                    statsLabel.className = 'key-stats';
                    statsLabel.innerHTML = `
                        <span class="stat-offset">${avgOffset >= 0 ? '+' : ''}${avgOffset.toFixed(0)}ms</span>
                        <span class="stat-velocity">v${avgVel.toFixed(0)}</span>
                    `;
                    key.appendChild(statsLabel);
                }

                // Add note label
                const label = document.createElement('div');
                label.className = 'key-label';
                label.textContent = noteName + octave;
                key.appendChild(label);

                pianoContainer.appendChild(key);
            }

            // Create black keys
            for (let i = 0; i < whiteKeyPositions.length - 1; i++) {
                const currentWhite = whiteKeyPositions[i];
                const nextWhite = whiteKeyPositions[i + 1];

                // Check if there should be a black key between these white keys
                for (let midi = currentWhite.midi + 1; midi < nextWhite.midi; midi++) {
                    const noteIndex = midi % 12;
                    const noteName = noteNames[noteIndex];

                    if (blackKeyNotes.includes(noteName)) {
                        const octave = Math.floor(midi / 12) - 1;
                        const fullNoteName = noteName + octave;

                        const key = document.createElement('div');
                        key.className = 'black-key';
                        key.dataset.midi = midi;
                        key.dataset.note = fullNoteName;

                        // Position the black key
                        const xPos = currentWhite.x + 46 - 14; // Center between white keys
                        key.style.left = (xPos + 5) + 'px'; // +5 for piano padding

                        // Check if this note was played
                        if (noteMap[midi]) {
                            const noteData = noteMap[midi];
                            const lastPlayed = noteData[noteData.length - 1];

                            key.classList.add('played');
                            if (lastPlayed.isDeviation) {
                                key.classList.add('deviation');
                            } else {
                                key.classList.add(direction);
                            }

                            // Add finger badge
                            if (lastPlayed.fingering) {
                                const badge = document.createElement('div');
                                badge.className = 'finger-badge' + (lastPlayed.isCrossing ? ' crossing' : '');
                                badge.textContent = lastPlayed.fingering;
                                key.appendChild(badge);
                            }

                            // Add sequence numbers
                            const seqNums = noteData.map(n => n.sequenceIndex).join(',');
                            const seqLabel = document.createElement('div');
                            seqLabel.className = 'sequence-number';
                            seqLabel.textContent = seqNums.length > 4 ? seqNums.substring(0, 3) + '‚Ä¶' : seqNums;
                            key.appendChild(seqLabel);

                            // Add stats (Avg Offset and Avg Velocity)
                            const avgOffset = noteData.reduce((sum, n) => sum + n.offsetMs, 0) / noteData.length;
                            const avgVel = noteData.reduce((sum, n) => sum + n.velocity, 0) / noteData.length;

                            const statsLabel = document.createElement('div');
                            statsLabel.className = 'key-stats';
                            statsLabel.innerHTML = `
                                <span class="stat-offset">${avgOffset >= 0 ? '+' : ''}${avgOffset.toFixed(0)}ms</span>
                                <span class="stat-velocity">v${avgVel.toFixed(0)}</span>
                            `;
                            key.appendChild(statsLabel);
                        }

                        pianoContainer.appendChild(key);
                    }
                }
            }
        }

        function renderPatternTimeline(containerId, notes, direction) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            if (notes.length === 0) {
                const emptyMsg = document.createElement('span');
                emptyMsg.className = 'empty-section-message';
                emptyMsg.textContent = 'No notes';
                emptyMsg.style.padding = '0.5rem';
                container.appendChild(emptyMsg);
                return;
            }

            notes.forEach((note, idx) => {
                // Add arrow between notes (except before first)
                if (idx > 0) {
                    const arrow = document.createElement('span');
                    arrow.className = 'pattern-arrow';
                    const prevNote = notes[idx - 1];
                    if (note.midi > prevNote.midi) {
                        arrow.textContent = '‚Üí';
                    } else if (note.midi < prevNote.midi) {
                        arrow.textContent = '‚Üê';
                    } else {
                        arrow.textContent = '‚Ä¢';
                    }
                    container.appendChild(arrow);
                }

                // Create note element
                const noteEl = document.createElement('div');
                noteEl.className = 'pattern-note';

                if (note.isDeviation) {
                    noteEl.classList.add('deviation');
                } else {
                    noteEl.classList.add(direction);
                }

                // Create note name
                const noteName = document.createElement('span');
                noteName.className = 'note-name';
                noteName.textContent = note.name;

                // Create finger number
                const fingerNum = document.createElement('span');
                fingerNum.className = 'finger-num';
                fingerNum.textContent = note.fingering ? note.fingering : '?';
                if (note.isCrossing) {
                    fingerNum.textContent += '‚Üª';
                }

                noteEl.appendChild(noteName);
                noteEl.appendChild(fingerNum);

                // Add tooltip with details
                noteEl.title = `Note: ${note.name}\nFinger: ${note.fingering}\nVelocity: ${note.velocity}\nOffset: ${note.offsetMs.toFixed(1)}ms${note.isDeviation ? '\n‚ö†Ô∏è DEVIATION' : ''}${note.isCrossing ? '\nüîÑ Crossing' : ''}`;

                container.appendChild(noteEl);
            });
        }

        function updatePianoInfo(notes) {
            const infoEl = document.getElementById('piano-info');

            if (notes.length === 0) {
                infoEl.textContent = 'No notes to display';
                return;
            }

            const midiNumbers = notes.map(n => n.midi);
            const minNote = notes.find(n => n.midi === Math.min(...midiNumbers));
            const maxNote = notes.find(n => n.midi === Math.max(...midiNumbers));

            const ascNotes = notes.filter(n => n.direction === 'ascending').length;
            const descNotes = notes.filter(n => n.direction === 'descending').length;
            const deviations = notes.filter(n => n.isDeviation).length;
            const devRate = (deviations / notes.length) * 100;
            const crossings = notes.filter(n => n.isCrossing).length;

            let info = `<strong>Total:</strong> ${notes.length} notes | <strong>Range:</strong> ${minNote.name} ‚Üí ${maxNote.name}`;
            if (crossings > 0) info += ` | üîÑ ${crossings} crossings`;
            if (deviations > 0) info += ` | ‚ö†Ô∏è ${deviations} deviations (${devRate.toFixed(1)}%)`;

            infoEl.innerHTML = info;
        }
    </script>
</body>

</html>